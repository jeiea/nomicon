# Safe와 Unsafe의 만남

![safe and unsafe](img/safeandunsafe.svg)

저수준 구현의 세부사항을 걱정할 필요가 없으면 아주 좋을 겁니다.
빈 튜플이 공간을 얼마나 차지하는지 누가 신경쓸까요? 슬프게도, 이건
때때로 중요하고 걱정해야 할 때도 있습니다. 개발자들이 세부 구현을 신경쓰기
시작하는 가장 흔한 이유는 성능이지만, 더 중요한 건 세부 구현이 하드웨어나 운영체제,
다른 언어와 직접 소통할 때 무결성의 문제가 될 수 있다는 점입니다.

세부 구현이 안전한 프로그래밍 언어에서 중요해질 때 프로그래머는 대개 세 가지 선택지를 가집니다.

* 컴파일러나 런타임 환경에서 최적화를 수행할 수 있도록 코드를 변경하기
* 관용적이지 않거나 복잡한 디자인으로 원하는 구현을 얻기
* 그런 세부사항을 다룰 수 있는 언어를 사용해 재구현하기

마지막 선택지에서 프로그래머들이 주로 쓰는 언어는 *C*입니다. C 인터페이스만 선언한 시스템과 소통하려면 심심치 않게 필요합니다.

그럼에도, C는 사용하기 매우 안전하지 않고 (때때로 좋은 이유에서지만),
이 위험성은 다른 언어와 소통하려할 때 증폭됩니다. C와 다른 언어가 서로
무슨 일이 일어날지 납득하고, 서로의 방해를 하지 않을지 확신하는데 신경써야 합니다.

그래서 Rust하고는 뭘 해야 할까요?

C와는 달리, Rust는 안전한 프로그래밍 언어입니다.

하지만 C처럼 Rust는 안전하지 않은 프로그래밍 언어입니다.

더 정확히 말하자면, Rust는 안전하기도 안전하지 않기도 한 프로그래밍 언어를 둘 다 *포함합니다*.

Rust는 *안전한 Rust*와 *안전하지 않은 Rust*라는 두 프로그래밍 언어의 조합으로
생각할 수 있습니다. 편리하게도 이 이름은 의미하는 걸 정확히 나타냅니다.
안전한 Rust는 안전합니다. 안전하지 않은 Rust는, 음, 그렇지 않겠죠. 사실
안전하지 않은 Rust는 *정말로* 위험한 행위를 허용합니다. Rust 개발자들이
하지 말라고 간청하지만, 우리는 어찌됐건 할 그런 것들 말이죠.

안전한 Rust는 *진짜* Rust 프로그래밍 언어입니다. 만약 우리가 모든 걸 
안전한 Rust로 짠다면, 타입 안전성이나 메모리 안전성을 걱정할 이유가 없습니다. 
허상 포인터나, 해제 후 재사용, 기타 모든 약속되지 않은 동작으로 고통받는
일이 사라질 겁니다.

표준 라이브러리 또한 고성능 응용 프로그램과 라이브러리를 순수하고 관용적인 안전한 러스트로 작성하는데 충분한 도구를 제공합니다. 

그럼에도 다른 언어와 소통하고 싶을 수 있습니다. 표준 라이브러리에 드러나지 않은
저수준 추상화를 작성할 수도 있습니다. (Rust로 전부 짠) 표준 라이브러리를 *짜는*
중일 수도 있습니다. 타입 시스템이 이해하지 못하는 뭔가를 해야해서 혈압이
올랐을 수 있습니다. 안전하지 않은 Rust가 필요한 겁니다.

안전하지 않은 Rust는 안전한 Rust와 규칙과 의미론에서 비슷합니다.
안전하지 않은 Rust는 결코 안전하지 않은 (다음 장에서 배울)
*몇 가지* 작업들을 허용합니다.

이 분리가 좋은 점은 C같은 안전하지 않은 언어를 쓰는 장점을 누릴 수 있다는 겁니다.
세부 구현을 통한 저수준 제어라는 장점을 완전히 다른 안전한 언어와 통합하는데 드는
수고나 문제없이 말이죠.

아직 문제는 남아있습니다. 대표적으로 우리는 타입 시스템이 무엇을 기대하는지 숙지하고
안전하지 않은 Rust와 소통하는 모든 코드에서 그 기대를 깨지 말아야 합니다. 그게
이 책의 목적입니다. 이 기대가 무엇이고 어떻게 다루는지를 가르치는 것 말이죠.