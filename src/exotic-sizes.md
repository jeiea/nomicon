# Exotically Sized Types

대개 우린 타입이 컴파일 시간에 알 수 있는 양수 크기를 가진다고 기대합니다.
하지만 러스트에선 항상 그렇진 않습니다.





# 가변 크기 타입(Dynamically Sized Types, DSTs)

러스트는 컴파일 시간에 크기나 정렬 값을 알 수 없는 가변 크기 타입을
지원합니다. 얼핏 보기에 말이 안 됩니다. 러스트가 타입을 잘 다루려면 크기와
정렬 값을 알아야 합니다. 그런 이유에서, DST는 평범한 타입이 아닙니다.
컴파일 시간에 크기를 알 수 없기 때문에 DST는 포인터 비슷한 것을 거쳐서만
존재할 수 있습니다. DST를 가리키는 모든 포인터는 포인터 자체와
DST를 완성시키는 보충 정보를 가진 *와이드* 포인터가 됩니다.
(아래에서 설명합니다)

러스트에서 쓸 수 있는 DST가 두 가지 있습니다.

* 트레잇 객체: `dyn MyTrait`
* 슬라이스: `[T]`, `str` 등등

트레잇 객체는 지정한 트레잇을 구현한 타입을 나타냅니다.
타입을 쓰는데 필요한 모든 정보를 담은 vtable로 런타임 리플렉션이 가능하고
정확한 원래 타입은 필요가 없어 *지워집니다*.
즉 트레잇 객체를 완성시키는 추가 정보는 그 vtable을 가리키는 포인터입니다.
가리킨 객체의 런타임 크기는 vtable에서 동적으로 알아올 수 있습니다.

슬라이스는 연속적인 저장 공간을 나타내는 객체입니다. 배열이나 `Vec`을 생각할
수 있습니다. 슬라이스 포인터를 완성시키는 추가 정보는 가리키는 원소 갯수입니다.
가리킨 슬라이스의 런타임 크기는 원소의 정적 크기에 원소 갯수를 곱한 값입니다.

구조체의 마지막 필드에도 DST를 넣을 수 있습니다. 하지만 그럴 경우 구조체
자체도 DST가 됩니다.

```rust
// 스택에 직접 넣을 수 없음
struct MySuperSlice {
    info: u32,
    data: [u8],
}
```

그런 타입은 생성하는 방법이 없으면 대개 쓸모 없습니다. 현재로썬
제네릭 타입에 *unsizing coercion*을 하는 게 커스텀 DST를 만드는
유일한 방법입니다.

```rust
struct MySuperSliceable<T: ?Sized> {
    info: u32,
    data: T,
}

fn main() {
    let sized: MySuperSliceable<[u8; 8]> = MySuperSliceable {
        info: 17,
        data: [0; 8],
    };

    let dynamic: &MySuperSliceable<[u8]> = &sized;

    // prints: "17 [0, 0, 0, 0, 0, 0, 0, 0]"
    println!("{} {:?}", dynamic.info, &dynamic.data);
}
```

(현재로썬 커스텀 DST는 반쪽짜리 기능이 맞습니다.)





# 영 크기 타입 (Zero Sized Types, ZSTs)

러스트는 공간을 차지하지 않는 타입도 허용합니다.

```rust
struct Nothing; // 필드 없음 = 크기 없음

// 모든 필드가 크기 없음 = 크기 없음
struct LotsOfNothing {
    foo: Nothing,
    qux: (),      // 빈 터플은 크기 없음
    baz: [u8; 0], // 빈 배열은 크기 없음
}
```

ZST는 그 자체로는 명백하게 필요가 없습니다. 하지만 러스트의 여러
아리송한 레이아웃 방식과 합쳐져 제네릭 사용 시에 그 잠재력이 발휘됩니다.
러스트는 ZST를 만들거나 저장하는 모든 연산은 생략할 수 있는 걸
잘 알고 있습니다. 우선, ZST를 저장하는 건 말이 안 됩니다.
ZST는 차지하는 공간이 없기 때문입니다. 또한 한 종류의 값밖에
없는 게 당연하고 차지하는 공간도 없기에 ZST를 불러오는 것
또한 생략할 수 있습니다.

ZST의 극단적인 예로는 셋과 맵이 있습니다. `Map<Key, Value>`가 있을 때
`Set<Key>`를 `Map<Key, UselessJunk>`를 사용해 구현하는 것은 흔합니다.
많은 언어가 저 UselessJunk의 공간을 오직 버리기 위해서 할당, 저장하고 불러오는
것을 요구합니다. 이게 불필요하다고 증명하는 것은 컴파일러에겐 힘든
분석일 겁니다.

하지만 러스트에선 `Set<Key> = Map<Key, ()>`이라고 할 수 있습니다.
러스트는 모든 불러오기와 저장이 의미가 없는 것과 모든 할당이
크기가 없을 것을 정적 시간에 알고 있습니다. 결과적으로 특수화해 생성한
HastSet 코드는 HashMap이 DST 값을 지원하는데 필요한 부하가
제거된 구현이 됩니다.

세이프 코드는 ZST를 걱정할 필요가 없지만, *언세이프* 코드는 반드시 크기없는
타입이 일으킬 효과를 생각해야 합니다. 특히 포인터 오프셋 연산이 사라지고,
메모리 할당기는 대개 [0이 아닌 크기를 요구합니다][alloc].

(빈 슬라이스를 포함한) ZST 레퍼런스는 다른 레퍼런스처럼 반드시 널이 아니고
잘 정렬되어 있어야 합니다. 널 또는 정렬되지 않은 ZST 포인터를 참조하는 건
다른 타입과 마찬가지로 [미정의 동작][ub]입니다.

[alloc]: https://doc.rust-lang.org/std/alloc/trait.GlobalAlloc.html#tymethod.alloc
[ub]: what-unsafe-does.html



# 빈 타입 (Empty Types)

러스트는 실제로 *인스턴스화할 수 없는* 타입의 선언도 허용합니다. 이런 타입은
타입 수준에서만 확인할 수 있고, 값 수준에서는 존재할 수 없습니다.
빈 타입은 멤버가 없는 열거형으로 정의할 수 있습니다.

```rust
enum Void {} // 멤버 없음 = 비어 있음
```

빈 타입은 ZST보다 더 자유롭습니다. 대표적인 빈 타입의 예로 타입 수준의
도달 불가능성이 있습니다. 예를 들어 어떤 API가 일반적으로 Result를
반환하지만 특정 경우에 실패할 수 없을 수 있습니다. 이 경우는
`Result<T, Void>`를 반환해 타입 수준으로 나타낼 수 있습니다.
API 사용자는 `Void`의 값을 만들 수 없다는 사실에서 Result의 값이
*정적으로* `Err`가 되는 게 불가능하다는 걸 알기에 안심하고 풀어낼 수 있습니다.

러스트는 이 사실에 근거해 몇가지 흥미로운 분석과 최적화를 수행합니다.
가령 `Result<T, Void>`는 `T`가 되는데 `Err`가 되는 경우가
실제로 없기 때문입니다. (엄밀히 말하면 이건 보장된 최적화는 아닙니다.
transmute는 여전히 미정의 동작입니다.)

다음 예제도 컴파일 가능*했습니다*.

```rust,ignore
enum Void {}

let res: Result<u32, Void> = Ok(0);

// Err가 존재하지 않기 때문에, Ok인게 확실하다.
let Ok(num) = res;
```

하지만 아직 이런 트릭은 쓸 수 없습니다.

빈 타입에 관한 마지막 토막지식은 빈 타입을 가리키는 raw 포인터를 만들 순
있지만 그걸 참조하는 건 말이 안 되기에 미정의 동작을 일으킨다는 겁니다.

우린 C의 `void*`타입을 `*const Void`로 모델링하는 걸 비추천합니다.
많은 사람들이 그러다가 얼마 안 가 난관에 빠지는데 러스트는 unsafe
코드에서 빈 타입을 인스턴스화 하는 것에 대해 어떤 안전 장치도 없기 때문입니다.
그리고 그건 미정의 동작입니다.
특히 개발자들이 raw 포인터를 레퍼런스로 변환하는 습관이 있어서 문제가 큰데,
`&Void`를 만드는 것 *또한* 미정의 동작입니다.

`*const ()` (혹은 동등한 것)은 `void*`을 잘 나타낼 수 있습니다. 또한 어떤 안전
문제없이 레퍼런스로 만들 수 있습니다. 값을 읽고 쓰는 걸 막지도 않을 것이며,
그걸 NOP으로 만들지언정 미정의 동작을 만들진 않을 겁니다.





# 외부 타입

러스트 개발자가 C의 `void*`와 기타 "선언됐지만 정의되지 않은" 타입을
더 정확히 표현하기 위한 크기를 알 수 없는 타입을 추가하자는
[승인된 RFC][extern-types]가 있습니다. 하지만 Rust 2018 시점에서
이 기능은 `size_of::<MyExternType>()`을 어떻게 처리하냔 문제에 막혀있습니다.




[dst-issue]: https://github.com/rust-lang/rust/issues/26403
[extern-types]: https://github.com/rust-lang/rfcs/blob/master/text/1861-extern-types.md
